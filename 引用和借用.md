### 引用和借用

Rust 中的借用有一些规则：

1. 任何借用必须位于比拥有者更小的作用域。

2. 对于同一个资源（resource）的借用，以下情况不能同时出现在同一个作用域下：

- 1 个或多个不可变引用（`&T`）
- 唯一 1 个可变引用（`&mut T`）

> 即同一个作用域下，要么只有一个对资源 A 的可变引用（&mut T），要么有 N 个不可变引用（&T），但不能同时存在可变和不可变的引用



### 总结

单纯Rust语言上考虑。 我们在不同情况下解释`&`的意思：

1. 在表达式上，表示的是借用。(&a右值)

2. 在变量绑定上，表示解地址操作与*类似。(&a左值)

3. 在类型声明上，表示引用类型。(&i32)

4. 在模式匹配上，**无效关键字**。



那么`ref`的通用解释是：

1. 在表达式上，**无效关键字**。

2. 在变量绑定上，表示引用类型。(ref a左值)

3. 在类型声明上，**无效关键字**。

4. 在模式匹配上，表示引用类型。( let ref a = b)



> 非要给区分`ref`和`&`到底哪个是引用，哪个是借用。我们可以先从词性划分，引用我归类为名词，而借用归类为动词。`&A`在表达式上 表示借用A，这是一个动作，那结果就是产出一个引用类型。所以`let ref B`表示声明了一个引用类型，它只能绑定到某次借用动作上。
>
> **所以`ref` 更适合称引用， `&`称借用。**

**例子：**

```rust
fn main() {
    let a = 1;
    let x1 = &a; // 表达式
    let &x2 = &a; // 变量
    test01(x1);


    let ref y1 = a; // 变量绑定
    match a {
        ref y2 => println!("test:{}", y2),
    }
}

fn test01(x3: &i32) -> i32 {
    *x3
}
```

